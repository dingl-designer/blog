RMI是dubbo框架实现的基础，官方教程：

[Java Remote Method Invocation - Distributed Computing for Java](https://www.oracle.com/technetwork/java/javase/tech/index-jsp-138781.html)



#### 概述

​	RMI提供了一个简单而直接的使用Java对象进行分布式计算的模型，具有Java在分布式计算方面的安全性和可移植性（portability）的优势。

​	RMI可以使用标准的Java本地方法接口（native method interface-JNI）连接现有的旧系统，也可以使用标准的JDBC包连接现有的关系型数据库。

####  优势

​	可以说，RMI是Java对于远程过程调用（remote procedure call-RPC）机制的实现。传统的RPC是语言中立的（language-neutral），所以它只提供在所有可能的目标平台上都可用的通用功能。RMI专注于Java，拥有基于本地方法建立的与现有系统的连接，这意味着RMI可以通过自然、直接的途径为您提供分布式计算技术，使您能够在整个系统中渐进而无缝地添加Java功能。

​	RMI的基本优势：

* 面向对象：RMI中，参数和返回值可以是完整对象（比如hashtable对象），而不仅仅是预定义的数据类型。而传统的RPC系统中，您必须让客户端将这样的对象分解为原始数据类型，并在服务器端重新组装。
* 移动行为：RMI可以在客户端和服务端之间移动行为（实现类）。例如你定义了一个接口，用户调用接口时，客户端从服务端取得实现类，如果服务端实现类发生变化，就会开始向客户端返回新的实现类。实现类的一致性由客户端负责检查（更快的响应用户且减轻服务端负载）而无需向用户系统安装新的软件。这提供了很大的灵活性，因为业务的改变只需要写一个新的Java对象且在服务端进行一次安装。
* 设计模式：对象的传递使得可以在分布式计算中发挥面向对象技术的全部优势，比如二层和三层架构（two- and three-tier）系统。当你可以传递行为的时候，你就可以使用面向对象设计模式。如果不能完整地传递对象（包括实现和类型），设计模式的优势就会消失。
* 安全可靠：RMI使用内置Java安全机制，当用户下载实现（implementations）时保证系统的安全。RMI使用安全管理器可以保护系统远离恶意小程序（hostile applets），这样可以保护你的系统和网络免受已经下载的（download**ed**）潜在恶意代码的攻击。
* 易写易用：RMI使得编写远程Java服务器和访问这些服务器的Java客户端变得简单。服务器只需要三行代码声明自己是服务器，其余部分和其他Java对象一样。
* 与现有系统的连接：RMI使用JNI与现有系统建立连接。使用RMI和JNI你可以使用Java写客户端并调用现有的服务器实现（implementation）。同样，RMI可以通过JDBC与现有关系型数据库交互而无需改变使用该数据库的非Java源。
* 一次编写，处处运行：如果是RMI/JDBC系统，可以100%移植到任何Java虚拟机；如果使用RMI/JNI与现有系统交互，使用JNI编写的代码可以使用任何Java虚拟机编译和运行。
* 分布式垃圾收集：RMI使用其分布式垃圾收集功能收集不再被任何客户端引用的远程服务器对象。
* 并行计算：RMI是多线程的，允许你的服务器使用Java线程对客户请求进行更好的并发（concurrent）处理。
* Java分布式计算解决方案：从JDK1.1开始RMI就是Java核心平台的一部分，存在于每一个1.1的Java 虚拟机中。所有的RMI系统通过相同的公共协议交流，无需任何协议转换开销。















