[文档地址](https://refactoring.guru/design-patterns)



**为什么要学设计模式？**设计模式方便编程人员之间进行交流。当某人说出一个实现模式，而无需描述细节，其他人也能领会到其要表达的含义。



**Factory Method**：主要元素包括一个创建者父类、若干创建者子类、一个接口以及实现该接口的若干产品类。其内在联系为：1、有继承关系的父类和子类创建者（Creator），负责创建产品（Product）的对象实例，子类通过重写（override）父类的产品创建函数`createProduct()`，创建不同种类的产品；2、接口定义了产品的行为，即各种产品类都实现了该接口声明的所有函数；3、父类定义产品的统一操作流程`someOperation()`，通常是通过调用接口的函数来实现，这些操作流程无需被子类重写。4、实际使用中，通过调用子类的产品创建函数来生产自定义的产品，通过调用子类继承自父类的操作流程函数来完成对产品的操作。

**Abstract Factory**：适用于产品家族问题。1、为产品家族的每个产品定义接口；2、声明抽象工厂，也是一个接口，该接口包含产品家族中每个产品的创建函数；3、为每个产品家族定义一个工厂类，该工厂类实现抽象工厂接口，负责创建特定家族的产品；4、客户端使用接口调用工厂和产品，这样当工厂和产品种类发生变化时，客户端的代码无需调整。

**Builder**：建造者模式适用于复杂产品的构建，以汽车为例。主要元素包括一个建造者接口和若干实现该接口的具体建造者类，以及一个指挥官类（若想要更细致化的产品控制，客户端可以直接取代指挥官行使控制行为）。这些角色的作用为：1、建造者接口定义生产产品所需的通用函数，比如`setSeats(),setEngine(),setGPS()`；2、建造者实现类负责对这些函数进行个性化的实现，比如有跑车的建造者和SUV的建造者，甚至是专门写说明手册的建造者；3、指挥官类负责指挥建造者的工作，其内部包含不同的产品的建造蓝图，比如`buildSportsCar(), buildSUV()`等，当客户端调用其`buildSportsCar()`函数时，指挥官初始化跑车的建造者，然后告诉他，先安装两个座位`setSeats(2)`，然后安装马达`setEngine(new Engine())`等等，同时还可以初始化用户手册的建造者，调用一遍相同的流程，最终客户端从两位建造者手中得到一辆跑车和一本相应的用户手册。

**Prototype**：原型模式就是复制模式。很多时候我们需要复制某个对象，每个对象属性不一且容易发生变化，所以声明一个原型（Prototype）接口，里面包含一个`clone()`函数，作为一个约定的标准。当我们需要复制一个实现了该接口的类的实例对象时，我们只要调用其`clone()`函数即可。

`clone()`函数的实现，需要借助一个构造函数，该构造函数接收一个同类型的对象，并将其属性赋值给刚刚创建的新对象（类似于`this.property = prototype.property;`）。比如在C++ 11标准中，这个隐形的构造函数是默认存在的。

**Singleton**：