[使用Java动态下载代码：java.rmi.server.codebase](https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html)



#### 1.0 开始

Java最重要的能力之一就是可以动态地将Java软件从统一资源定位器（Uniform Resource Locationor-URL）下载到虚拟机中，该虚拟机可以运行在另外一个进程中，一般是另一个物理系统的中。结果就是远程系统可以运行一个从未在磁盘上安装的程序（比如小应用程序applet）。本文档的前几节，讨论有关小应用程序的代码库（codebase），以帮助描述 Java RMI 的代码库。

例如，web浏览器运行的VM可以下载java.applet.Applet的子类的字节码以及该applet所需的任何其他类。运行浏览器的系统很可能从来没有运行过该applet，也不会把它安装到磁盘上。一旦所有需要的类都从服务器下载，浏览器就可以使用其所在系统的本地资源运行applet程序。

Java RMI利用这种能力在没有安装类文件的系统上下载和执行这些类文件。利用Java RMI API和VM，能够下载任何类型的class文件，包括RMI的存根（stub）类。

代码库的概念源于Java编程语言中类加载器（ClassLoaders）的使用。当Java程序使用类加载器时，该加载器需要知道从哪里加载类。很可能你第一次接触到加载器和代码库配对使用是AppletClassLoader和HTML标签`<applet>`中包含的代码库。例如，HTML资源可能包含如下：

```html
<applet height=100 width=100 codebase="myclasses/" code="My.class">
        <param name="ticker">
</applet>
```

#### 2.0代码库是什么

代码库可定义成资源或者位置，从这里可以加载类到虚拟机中。代码库是你告诉VM的路径，以便它能找到你的类。

你可以将`CLASSPATH`看作是“本地代码库”，因为他是磁盘上的位置列表，从这些位置可以加载本地类。当从本地磁盘加载类时，就会参照`CLASSPATH`变量。`CLASSPATH`变量可以包含相对或绝对路径，或者类文件的压缩包（archives）。相对而言，被小应用程序和远程对象使用的代码库可以看作是“远程代码库”。

#### 3.0 它如何实现

##### 3.1 小应用程序使用代码库

为了和小应用程序交互，小应用程序和所需的类文件必须能够被远程客户端访问。尽管小应用程序可以通过“ftp://”或者本地“file:///”访问，通常情况下，它们是通过远程HTTP服务器被访问。

​	1、客户端浏览器请求小应用程序类，该类在客户机`CLASSPATH`中找不到。

​	2、小应用程序的定义类（包括其他所需的类）从服务器通过HTTP下载到客户端。

​	3、小应用程序在客户端执行。

小应用程序的代码库总是和`<applet>`标签所在HTML页面的URL相关联。

##### 3.2 Java RMI使用代码库

使用Java RMI，应用可以创建远程对象，以接收来自客户端的方法调用。客户端为了调用远程对象的方法，必须找到和远程对象交互的途径。与其不得不编写客户端与远程对象交流的协议，Java RMI使用叫做存根的特殊类，该类可以下载到与远程对象交流的客户端。`java.rmi.server.codebase`属性值代表一个或多个可以下载存根（以及其他所需类）的路径。

与小应用程序一样，执行远程方法调用所需的类可以从“file:///”路径下载，但是和小应用程序一样，“file:///”一般要求客户端和服务器在同一物理主机上。除非文件系统使用其他协议（比如NFS）是URL可达。

一般来讲，执行远程方法调用所需的类应该是通过网络资源可访问的，比如HTTP或FTP服务器。（下面的1-5见图2，6见图3、4，7见图4）

​	1、远程对象的代码库被远程对象的服务器通过设置`java.rmi.server.codebase`属性来指定。Java RMI服务器通过Java RMI 注册器（registry）注册一个远程对象，并绑定一个名称。服务器VM上设置的代码库被注释到Java RMI注册器的远程对象引用（对象引用通过注释可定位代码库）。

​	2、Java RMI客户端请求已命名的远程对象的引用。引用（远程对象的存根实例）是指客户端通过其来完成对远程对象的远程方法调用。

​	3、Java RMI 注册器返回被请求类的引用（存根实例）。如果存根实例的类定义能够在本地`CLASSPATH`中被找到（总会在检索代码库之前被检索），客户端将会从本地加载类。然而，如果客户端`CLASSPATH`中找不到，客户端将会尝试从远程对象代码库取得（retrieve）类定义。

​	4、客户端通过代码库请求类定义。客户端使用的类定义是在注册器加载存根类时注释在存根实例上的URL。回到步骤1，导出对象的已注释存根就是在那时（步骤1时）注册到了Java RMI 注册器并绑定了名称。

​	5、存根（包括其他所需类）的类定义被下载到客户端。

​		**注意**：当远程对象使用注册器绑定名称的时候，注册器加载远程对象的步骤和4、5是一样的。当注册器尝试加载远程对象的存根类时，它会请求和远程对象相关联的代码库。（这里描述的是服务端的存根注册过程`registry.rebind(name, stub);`。RMI服务器的[示例代码](https://docs.oracle.com/javase/tutorial/rmi/implementing.html)。[客户端](https://docs.oracle.com/javase/tutorial/rmi/client.html)无需注册，可以直接从服务器获取注册信息）

​	6、现在客户端拥有了调用远程方法所需的全部信息。存根实例作为服务器上的远程对象的代理。**所以与应用小程序在在本地VM上执行代码不同，Java RMI 客户端使用远程对象的代码库在另外一个可能是远程VM上执行代码。**

#### 4.0 Java RMI 使用codebase不止下载存根

*注*：服务器和客户端都可以设置`codebase`属性

除了下载存根及关联类到客户端，`java.rmi.server.codebase`属性可以指定任何类（不止存根及其关联类）的下载路径。

当客户端调用远程对象的方法时，根据被调用的方法接收参数的类型，分为以下三种情况：

第一种情况，所有参数（包括返回值）是原始（primitive）数据类型，因此远程对象知道如何将它们翻译为参数，而不需要检查`CLASSPATH`或代码库。

第二种情况，至少有一个参数或返回值是一个对象，并且能在本地`CLASSPATH`中找到找到类定义。

第三种情况（步骤6，见图4），远程方法接收对象实例，并且远程对象在本地`CLASSPATH`找不到该对象实例的类定义（类定义对服务器不可知）。这种类型的方法调用在图4中进行了说明。客户端发送的对象类是已声明的参数类型的字类型。该字类型可以是：

* 声明作为方法参数或返回类型的接口的实现
* 声明作为方法参数或返回类型的类的子类

7、与小应用程序的代码库一样，客户端指定的代码库用来向其他VM下载远程或非远程类和接口。如果`codebase`属性设置在客户端应用上，那么当客户端加载子类时，代码库会被注释到子类实例上。如果客户端没有设置代码库，那么远程对象将会错误的使用它自己的代码库（导致找不到子类定义吧）。

#### 5.0 命令行示例

在小应用程序的例子中，小应用程序的代码库值嵌入到HTML页面中，现我们在本教程第一部分看到的那样。

在Java RMI 代码库的例子中，与其引用嵌入HTML页面的类，客户端首先连接Java RMI注册器以获得对远程对象的引用。由于远程对象的代码库可以指向任何的URL，不是已知URL的相对路径，Java RMI代码库必须是绝对路径，该路径指向存根类和其他所需类的位置。这个`codebase`属性值可以指向：

* 一个路径URL，类按照包名组织存放在该路径的子路径下（大概是指类顶部的package属性）
* 一个jar包URL，在该文件中类按照包名组织存放在该路径下
* 一个以空格分隔的字符串，包含符合上述条件的多个jar文件或目录实例

注：当`codebase`属性设置为路径URL时（上面第一类和第三类），必须以“/”结尾。

示例：

`-Djava.rmi.server.codebase=http://webvector/export/`

`-Djava.rmi.server.codebase=http://webline/public/mystuff.jar`

`-Djava.rmi.server.codebase="http://webfront/myStuff.jar http://webwave/myOtherStuff.jar"`







