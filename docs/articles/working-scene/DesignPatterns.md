[文档地址](https://refactoring.guru/design-patterns)



**为什么要学设计模式？**设计模式方便编程人员之间进行交流。当某人说出一个实现模式，而无需描述细节，其他人也能领会到其要表达的含义。

#### Creational Patterns

**Factory Method**：主要元素包括一个创建者父类、若干创建者子类、一个接口以及实现该接口的若干产品类。其内在联系为：1、有继承关系的父类和子类创建者（Creator），负责创建产品（Product）的对象实例，子类通过重写（override）父类的产品创建函数`createProduct()`，创建不同种类的产品；2、接口定义了产品的行为，即各种产品类都实现了该接口声明的所有函数；3、父类定义产品的统一操作流程`someOperation()`，通常是通过调用接口的函数来实现，这些操作流程无需被子类重写。4、实际使用中，通过调用子类的产品创建函数来生产自定义的产品，通过调用子类继承自父类的操作流程函数来完成对产品的操作。

**Abstract Factory**：适用于产品家族问题。1、为产品家族的每个产品定义接口；2、声明抽象工厂，也是一个接口，该接口包含产品家族中每个产品的创建函数；3、为每个产品家族定义一个工厂类，该工厂类实现抽象工厂接口，负责创建特定家族的产品；4、客户端使用接口调用工厂和产品，这样当工厂和产品种类发生变化时，客户端的代码无需调整。

**Builder**：建造者模式适用于复杂产品的构建，以汽车为例。主要元素包括一个建造者接口和若干实现该接口的具体建造者类，以及一个指挥官类（若想要更细致化的产品控制，客户端可以直接取代指挥官行使控制行为）。这些角色的作用为：1、建造者接口定义生产产品所需的通用函数，比如`setSeats(),setEngine(),setGPS()`；2、建造者实现类负责对这些函数进行个性化的实现，比如有跑车的建造者和SUV的建造者，甚至是专门写说明手册的建造者；3、指挥官类负责指挥建造者的工作，其内部包含不同的产品的建造蓝图，比如`buildSportsCar(), buildSUV()`等，当客户端调用其`buildSportsCar()`函数时，指挥官初始化跑车的建造者，然后告诉他，先安装两个座位`setSeats(2)`，然后安装马达`setEngine(new Engine())`等等，同时还可以初始化用户手册的建造者，调用一遍相同的流程，最终客户端从两位建造者手中得到一辆跑车和一本相应的用户手册。

**Prototype**：原型模式就是复制模式。很多时候我们需要复制某个对象，每个对象属性不一且容易发生变化，所以声明一个原型（Prototype）接口，里面包含一个`clone()`函数，作为一个约定的标准。当我们需要复制一个实现了该接口的类的实例对象时，我们只要调用其`clone()`函数即可。

`clone()`函数的实现，需要借助一个构造函数，该构造函数接收一个同类型的对象，并将其属性赋值给刚刚创建的新对象（类似于`this.property = prototype.property;`）。比如在C++ 11标准中，这个隐形的构造函数是默认存在的。

**Singleton**：单例模式解决两个问题：1、保证每个类只有一个实例对象，以便控制对共享资源的访问；2、提供一个全局的访问指针，将该实例对象作为全局变量使用。

具体实现步骤为：1、类内部增加一个私有静态属性（`instance`），用来存储单例；2、向外部提供公共静态函数（`getInstance()`）用于获取单例；3、在`getInstance()`内实现类的延迟初始化，第一次调用时创建新的实例并赋值给`instance`并返回，之后的调用直接返回已创建的`instance`；4、将类的构造函数变为私有（private），只有在类内部才能调用。

*注*：Spring框架也使用单例模式，但是Spring Singleton 不同于此处的Singleton。[Spring Singleton vs Singleton Pattern](https://www.javadevjournal.com/spring/spring-singleton-vs-singleton-pattern/)

#### Structural Patterns

**Adapter**：一个常见的适配器是数据转换适配器。比如现有系统可以接收XML格式数据并进行展示，后来新增的第三方数据源只提供JSON格式数据，那么就加一个适配器将JSON格式转换为XML格式。

实现方式：1、适配器为调用方提供一个接口，当调用方通过，适该接口调用适配器时，配器将接收到的请求转换成被调用方能够理解的形式，该方法称为对象适配（Object adapter）；2、另外一种类适配（Class adapter）只在支持多继承的语言中才能实现，比如C++。

