教程地址：[Dive Into DESIGN PATTERNS](https://refactoring.guru/design-patterns)



#### Creational Patterns

**Factory Method**：主要元素包括一个父类创建者、若干子类创建者（Creator）、一个接口（用于声明产品的行为函数）以及实现该接口的若干产品类（Product）。其内在联系为：1、有继承关系的父类和子类创建者，负责创建产品的对象实例，子类通过重写（override）父类的产品创建函数`createProduct()`，创建不同种类的产品；2、接口定义了产品的行为，即各种产品类都实现了该接口类声明的所有函数；3、父类定义产品的统一操作流程`someOperation()`，通常是通过调用接口中声明的产品行为函数来实现，这些操作流程无需被子类重写。4、实际使用中，通过调用子类创建者的创建函数来生产自定义的产品，通过调用子类创建者继承自父类创建者的操作流程函数来完成对产品的操作。

**Abstract Factory**：适用于产品家族问题。1、为产品家族的每个产品定义接口；2、声明抽象工厂，也是一个接口，该接口包含产品家族中每个产品的创建函数；3、为每个产品家族定义一个工厂类，该工厂类实现抽象工厂接口，负责创建特定家族的产品；4、客户端使用接口调用工厂和产品，这样当工厂和产品种类发生变化时，客户端的代码无需调整。

**Builder**：建造者模式适用于复杂产品的构建。该模式的主要元素包括一个建造者接口和若干实现该接口的具体建造者类，以及一个指挥官类（若想要更细致化的产品控制，客户端可以直接取代指挥官行使控制行为）。以建造汽车为例，这些角色的作用为：1、建造者接口定义生产产品所需的通用函数，比如`setSeats()`, `setEngine()`, `setGPS()`；2、建造者实现类负责对这些函数进行个性化的实现，比如有跑车的建造者和SUV的建造者，甚至是专门写说明手册的建造者；3、指挥官类负责指挥建造者的工作，其内部包含不同的产品的建造蓝图，比如`buildSportsCar(), buildSUV()`等，当客户端调用其`buildSportsCar()`函数时，指挥官初始化跑车的建造者，然后告诉他，先安装两个座位`setSeats(2)`，然后安装马达`setEngine(new Engine())`等等，同时还可以初始化用户手册的建造者，调用一遍相同的流程，最终客户端从两位建造者手中得到一辆跑车和一本相应的用户手册。

**Prototype**：原型模式就是复制模式。很多时候我们需要复制某个对象，每个对象属性不一且容易发生变化，所以声明一个原型（Prototype）接口，里面包含一个`clone()`函数，作为一个约定的标准。当我们需要复制一个实现了该接口的类的实例对象时，我们只要调用其`clone()`函数即可。

`clone()`函数的实现，需要借助一个构造函数，该构造函数接收一个同类型的对象，并将其属性赋值给刚刚创建的新对象（类似于`this.property = prototype.property;`）。比如在C++ 11标准中，这个隐形的构造函数是默认存在的。

**Singleton**：单例模式解决两个问题：1、保证每个类只有一个实例对象，以便控制对共享资源的访问；2、提供一个全局的访问指针，将该实例对象作为全局变量使用。

具体实现步骤为：1、类内部增加一个私有静态属性（`instance`），用来存储单例；2、向外部提供公共静态函数（`getInstance()`）用于获取单例；3、在`getInstance()`内实现类的延迟初始化，第一次调用时创建新的实例并赋值给`instance`并返回，之后的调用直接返回已创建的`instance`；4、将类的构造函数变为私有（private），只有在类内部才能调用。

*注*：Spring框架也使用单例模式，但是Spring Singleton scope 不同于此处的Singleton。Spring的singleton scope是指每个容器每个给定的bean id （per container and per bean）创建一个唯一的实例对象。详见：

* [Spring Singleton vs Singleton Pattern](https://www.javadevjournal.com/spring/spring-singleton-vs-singleton-pattern/) 
* [The singleton scope](https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/html/beans.html#beans-factory-scopes-singleton)

#### Structural Patterns

**Adapter**：一个常见的适配器是数据转换适配器。比如现有系统可以接收XML格式数据并进行展示，后来新增的第三方数据源只提供JSON格式数据，那么就加一个适配器将JSON格式转换为XML格式。

实现方式：1、适配器为调用方提供一个接口，当调用方通过，适该接口调用适配器时，配器将接收到的请求转换成被调用方能够理解的形式，该方法称为对象适配（Object adapter）；2、另外一种类适配（Class adapter）只在支持多继承的语言中才能实现，比如C++。

**Bridge**：桥接模式比较难理解。这里参考[geeksforgeeks](https://www.geeksforgeeks.org/bridge-design-pattern/)网站的扼要介绍，可以了解到该模式的主要思想。该模式主张将软件分成两层架构，抽象和实现（或者接口和实现、前端和后端等等）。抽象是指类本身，而其能做的事作为实现（所以这里的“实现”和实现接口的“实现”不是同一概念，这里的实现是以接口的形式存在的）。抽象和实现可以单独变化而不影响另外一层结构。桥接模式就是为了应对这种变化而提出的。

本文中的第一个例子（使用形状和颜色）存在不太恰当的地方，它容易让初学者认为形状和颜色是两个并列的属性，但其实作者想表达的，形状是作为形状的子类，而涂色是其能做的事，两者不是并列的，而是存在主次的。geeksforgeeks网站使用Vehicle的例子就不具有这样的迷惑性，因此更易理解。

**Composite**：组合模式适用于树形结构，即包括分支和叶子结点。比如调用树形结构的求和函数，树形结构将遍历其所有分支，每个分支再遍历其所有叶子节点，最终由叶子节点返回结果并向上传递。

具体实现步骤为：1、确保核心模型可以用树形结构表示，即可以分解成简单元素和容器，且容器可以包含简单元素和其他容器；2、为简单元素和容器声明统一的组件接口（component interface），该接口包含所有组件（简单元素和容器）需要实现的函数；3、创建叶子结点类，代表简单的元素，叶子结点类可以有多个；4、创建容器类，该类提供一个数组用来存储子元素，为了使该数组可以同时存放简单元素和容器，数组元素使用组件接口来声明；5、为容器定义添加和删除子元素的函数。

**Decorator**：装饰者，也叫包装器。文章最后的数据源的例子最容易理解，在写入数据之前使用包装器对数据进行压缩和加密，读取数据时使用包装器对数据进行解密和解压缩。其中父类包装器通过实现和被包装对象相同的接口来完成对对象的包装，而子类包装器通过重写这个接口来完成功能的扩展。

具体实现步骤为：1、确认业务域可以表示为有多个可选外层的原始组件；2、提取原始组件和可选层的公共函数，声明为组件接口（component interface）；3、创建组件类（被包装类），定义其基本行为；4、创建基础装饰类（包装器），包含一个属性用来存放被包装对象的引用，该属性使用组件接口，以便既可以指向被包装类，又可以指向其他包装器（这也是为什么要提取包装器和被包装类共同的接口）；5、确保所有类都实现了组件接口；6、创建基础包装器的子类，这些子类在调用父类的行为之前或之后执行自己的行为；7、客户端（调用者）负责创建并组合包装器。

**Facade**：门面模式，关键字是“门”，即入口。有时候我们调用库或者框架的时候，需要使用其非常多的对象和函数，且这些对象或函数要按照一定的规则创建或调用。为了使业务代码和这些复杂的规则相分离，也为了便于库或者代码的替换或升级，应该将框架或库的使用封装到一个类或者方法中，只对外暴露较少的入口。文中使用了视频处理的例子，而我想到的例子是使用POI读写Excel。

**Flyweight**：翻译成“享元模式”虽然直接说明了该模式的内在逻辑，不是flyweight所代表的含义。flyweight（或lightweight）是指拳击运动中的轻量级，在这里则指创建轻量级的对象，以节省内存空间。

粒子系统是一个很好的场景。因为粒子系统会创建非常多的粒子，会占用大量的内存。并且粒子往往具有这样一些属性：1、这些属性是粒子的内在（intrinsic）属性，初始化完成后不再变化；2、这些属性为全部或部分粒子共有，即这些粒子具有相同的属性值。在这种情形下，可以只创建少量的粒子，通过对象的复用模拟大量粒子。内在属性之外的属性称为外在（extrinsic）属性，这些属性会随着程序的运行发生变化，这些属性值转由主程序（context）保存或计算。

因为外在属性的个数未发生变化，单纯的将粒子属性进行内在和外在的拆分不会节省内存，而是由于轻量级对象可以为更多的场景所共享，从而只需创建更少的对象，以达到节省内存的目的。这些少量的对象可以由工厂管理在对象池中。

*注*：[**String Pool in java**](https://www.journaldev.com/797/what-is-java-string-pool)也是轻量级模式的例子。

**Proxy**：代理模式为原始对象提供一个套件，在请求原始对象之前或之后做一些事。这听起来和装饰模式很像，但其实它有更多的权力，完全可以视作原始对象的替代品。比如代理模式可以控制在某些时候不调用原始对象（缓存代理），可以控制原始对象的懒加载和释放（虚拟代理），做一些和业务不相干的事（日志代理），或者将远程调用封装为本地调用（远程代理）。

实现步骤为：1、如果没有预定义的接口，定义一个，使得代理和服务类可以互换（JDK proxy）。提取服务接口并非总是可取的，方案B是定义代理类为服务类的子类，以此来继承服务（Cglib proxy）。2、创建代理类，该类包含一个属性以存放对服务的引用。通常代理类负责服务对象的创建和管理，有时候，也可能由客户端向代理类构造器中传入一个服务对象。3、根据需求实现代理方法。大多数情况下，在完成代理工作后，依旧将工作移交给服务对象，毕竟自己只是个代理。4、可以考虑引入一个方法，用来确定使用代理还是直接调用服务，这是可选的。5、可以考虑在代理中延迟初始化服务对象。

#### Behavior Patterns

**Chain of Responsibility**：责任链模式指在一个处理器链上（a chain of handlers）传递并处理请求。当接收到一个请求时，链上的每个处理器决定是对请求进行处理还是交由下一个处理器。

应用场景：1、如果你想用不同的方式处理不同的请求，将处理器连成链，并且在每个处理器收到请求时“询问”它是否可以处理请求；2、如果请求必须按照特定的顺序来处理，就将处理器按照指定的顺序连接；3、如果你为处理器类的引用属性添加设置函数（setter），就可以在运行时对处理器进行动态地插入、删除、重新排序。

文中使用了帮助信息的例子：GUI由不同层级的组件叠加组成，面板》对话框》按钮，上层组件的提示信息能够覆盖下层的提示信息，当用户请求帮助时，如果上层没有提示信息，就交由下层提示，如果都没有提示信息，就显示默认信息。

**Command**：命令模式将请求封装为一个独立的对象。这样的转化允许使用不同的请求进行方法的参数化、延迟或排列请求的执行，并支持撤销操作（将执行过的命令放入栈）。

命令模式是分层的产物，将GUI和后台逻辑进行分离，通过传递命令对象完成通信。我首先想到的是Ajax，根据[CoffeeScript](https://coffeescript-cookbook.github.io/chapters/design_patterns/command)网站的说法，是ajax传递的XmlHttpRequest对象使用的该模式。

**Iterator**：迭代器模式允许在不暴露集合的底层实现的情况下遍历集合元素，即将集合的遍历逻辑提取到迭代器类中，并且集合可以返回多种迭代器。该模式主要包含两个接口（Iterator和Collection）以及其实现类。比如当集合是一个二叉树时，可以返回[深度优先](https://zh.wikipedia.org/wiki/深度优先搜索)迭代器和[广度优先](https://zh.wikipedia.org/wiki/广度优先搜索)迭代器，而当集合为Facebook的社交网络图时，可以返回“朋友迭代器”和“同事迭代器”等。这样做带来的好处是，集合类和迭代器类可以保持多样性和扩展性，而保持调用方代码不变。

**Mediator**：中间人模式。该模式是为了减少对象之间混乱的依赖关系。严格限制对象之间的直接依赖，强制要求其通过中间人进行合作。也就是说，中间人将对象的依赖关系提取出来放在了单独的类中。

从Structure的第4点描述可以得知，通过中间人相互沟通的组件，意识不到彼此的存在，中间人像个黑箱子，发送通知的组件不知道他发出的通知会转发到那里去，接收到通知的组件也不知道该通知最初来自哪里。

实现方式为：将中间人声明为接口。相互依赖的组件持有对中间人接口实现对象的引用，并在通过该对象向中间人发起通知时，将自己作为参数传递过去。具体的中间人接口实现类亦持有对各个组件的引用，并在接收到组件通知时，通过参数判断通知的来源组件，并在必要的时候向其他相应组件发起通知。

**Memento**：记忆模式使能够在不暴露实现细节的情况下实现历史状态的保存和重载。常用于编辑器的撤回操作和事务回滚。

实现的关键在于由状态所属对象本身来进行状态的保存，以保证安全性，只向外部暴露有限的接口，另外需要一个栈结构来存储状态对象。在编辑器场景下，历史状态对象（ConcreteMemento）可以放在命令模式提取的Command对象里，当撤回一条Command时，重载其保存的命令执行之前的状态。

**Observer**：观察者模式定义了订阅（subscription）机制，用于当重要事情发生时向多个对象发起通知。这解决了不使用订阅机制时遇到的问题：如果不发起通知，观察者需要不断检查被观察对象状态；如果向所有对象发起通知，某些对象可能对此次事件并不感兴趣。

在订阅机制中，我们将被观察对象称作发布者（publisher），将观察者称为订阅者（subscriber）。发布者需要维护一个订阅者列表，以及添加或移出订阅者的接口，在需要发起通知时，遍历订阅者列表并依次通知。例子，Zookeeper。

**State**：状态模式允许对象在不同状态下拥有不同的行为。该模式适用于有限状态机（Finite-state Machine），比如当智能手机处于锁屏和非锁屏状态，点击屏幕会触发不同的动作。

实现方式为（以音乐播放器为例）：1、将所有按钮的点击行为声明为一个状态（State）接口，将具体状态定义为该接口的实现类，以实现该状态下按钮的点击行为；2、声明主程序（`Player`），包含一个状态接口实现类的引用（`state`），改变状态的函数（`changeState(state)`），以及各个按钮的点击行为（在函数内部再调用具体状态的点击行为）；3、当用户点击某个按钮时，比如`clickPlay()`，Player对象将请求传递给其state属性所指对象的`clickPlay()`函数。详见*Pseudocode*部分。

**Strategy**：策略模式定义一个算法家族，将每种算法封装为一个单独的类，并使这些类对象可以相互替代。比如地图中的路线推荐，根据不同的出行工具需要使用不同的算法，于是将步行算法、单车算法、公共交通算法、自驾算法封装为不同的类。

实现方式也比较简单，将算法抽象为策略（Strategy）接口，各种算法均实现该接口；Context类以接口的方式引用算法对象，并通过改变引用对象来进行算法切换。

**Template Method**：模板方法模式并非指泛型。该模式在超类（一般为抽象类）的**模板方法**中定义算法的框架并允许子类覆盖其中的某些步骤。该模式的一个特殊之处在于其使用抽象类来实现，因为算法框架已经在其模板方法（templateMethod()）中实现，只是某些步骤尚不明确。

实现步骤为：1、分析目标算法是否能够拆分为步骤，哪些步骤是所有所有子类通用的，哪些是独特的；2、创建抽象基类，声明模板方法和一系列代表算法步骤的抽象方法，将算法的结构提取到模板方法中，可以考虑将模板方法加上`final`限定以防止被子类覆盖；3、所有步骤都是抽象的也没关系，只是最好加一些默认实现，这样子类就可以选择不对其进行覆盖；4、可以在重要的步骤前后留一些钩子，方便子类扩展；5、为算法的每一个变体创建一个子类，该子类必须实现所有的抽象步骤，但也可以覆盖某些非抽象步骤。

**Visitor**：和Strategy和Template Method一样，访问者模式依旧是用来处理算法的。该模式将算法从其操作对象中分离出来。该模式的实现依赖重载（overload）和双重派遣（double dispatch）两种技术，其中双重派遣是为了避免使用笨重的条件判断。

其结构为：1、`Visitor`接口声明一系列的`visit`函数，每个函数接收不同的`element`对象作为参数，这里使用到了重载技术；2、每一个（可能只有一个）实现了`Visitor`接口的访问者类为不同的`Element`类实现不同的`visit`行为；3、`Element`接口声明一个`accept`方法来接收访问者，接收参数以`Visitor`接口类型声明；4、`Element`接口的实现类实现`accept`方法，目的是重新调用访问者中与当前对象类对应的`visit`函数；5、客户端（上下文）通常持有一个访问者和一个Element的集合（或者更复杂的对象，比如树），通过遍历每个`Element`对象并调用其`accept`方法来完成整个模式的调用。这也是为什么*不能通过访问者直接调用*，因为在遍历过程中并不知道每个`Element`的具体实现类，此时访问者的重载函数无法生效。

#### 基于[GoF](https://springframework.guru/gang-of-four-design-patterns)的补充或修正

第三个分类是**Behavior** Patterns，而不是*Behavioral* Patterns。

**Interpreter**：为一种语言定义语法表示，解释器使用该语法规则解释这种语言的句子。

一个形象的类比是，我们经常要解读手势，我们需要观察手势，然后给出一种解释，基于不同的文化，相同的手势还可能有不同的含义。

类似的，在变成世界里，我们从各种来源（自浏览器、GUI、命令行工具等）得到用户的输入，这个输入可能有不同的表达形式。当一种新的表达形式被引入时，我们不想更改发送输入的客户端代码。解决方案是使用解释其模式对通过客户端输入进来的表达式进行自动且灵活的处理。

使用解释器模式的目的是处理用户输入表达式并建立抽象语法树（Abstract Syntax Tree）。然后你需要一个解析器解析语法树（将句子解析成语法树结构）并生成输出。

当我们讨论输入表达式时，可以将它们和遵循某种表示法的数学表达式关联起来。比如反向波兰表示法（Reverse Polish notation）的`2 1 5 + *`，在Java中解释为`2*(1+5)`并输出12。

解释其模式定义的表达式分为两种：1、Terminal：树的叶子节点，不能包含其他的表达式，比如上例中的`2 1 5`；2、Nonterminal，非叶子结点，他们包含其他的表达式，比如上例中的 `* +` 。







