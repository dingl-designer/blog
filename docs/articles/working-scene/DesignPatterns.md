[文档地址](https://refactoring.guru/design-patterns)



**为什么要学设计模式？**设计模式方便编程人员之间进行交流。当某人说出一个实现模式，而无需描述细节，其他人也能领会到其要表达的含义。

#### Creational Patterns

**Factory Method**：主要元素包括一个创建者父类、若干创建者子类、一个接口以及实现该接口的若干产品类。其内在联系为：1、有继承关系的父类和子类创建者（Creator），负责创建产品（Product）的对象实例，子类通过重写（override）父类的产品创建函数`createProduct()`，创建不同种类的产品；2、接口定义了产品的行为，即各种产品类都实现了该接口声明的所有函数；3、父类定义产品的统一操作流程`someOperation()`，通常是通过调用接口的函数来实现，这些操作流程无需被子类重写。4、实际使用中，通过调用子类的产品创建函数来生产自定义的产品，通过调用子类继承自父类的操作流程函数来完成对产品的操作。

**Abstract Factory**：适用于产品家族问题。1、为产品家族的每个产品定义接口；2、声明抽象工厂，也是一个接口，该接口包含产品家族中每个产品的创建函数；3、为每个产品家族定义一个工厂类，该工厂类实现抽象工厂接口，负责创建特定家族的产品；4、客户端使用接口调用工厂和产品，这样当工厂和产品种类发生变化时，客户端的代码无需调整。

**Builder**：建造者模式适用于复杂产品的构建，以汽车为例。主要元素包括一个建造者接口和若干实现该接口的具体建造者类，以及一个指挥官类（若想要更细致化的产品控制，客户端可以直接取代指挥官行使控制行为）。这些角色的作用为：1、建造者接口定义生产产品所需的通用函数，比如`setSeats(),setEngine(),setGPS()`；2、建造者实现类负责对这些函数进行个性化的实现，比如有跑车的建造者和SUV的建造者，甚至是专门写说明手册的建造者；3、指挥官类负责指挥建造者的工作，其内部包含不同的产品的建造蓝图，比如`buildSportsCar(), buildSUV()`等，当客户端调用其`buildSportsCar()`函数时，指挥官初始化跑车的建造者，然后告诉他，先安装两个座位`setSeats(2)`，然后安装马达`setEngine(new Engine())`等等，同时还可以初始化用户手册的建造者，调用一遍相同的流程，最终客户端从两位建造者手中得到一辆跑车和一本相应的用户手册。

**Prototype**：原型模式就是复制模式。很多时候我们需要复制某个对象，每个对象属性不一且容易发生变化，所以声明一个原型（Prototype）接口，里面包含一个`clone()`函数，作为一个约定的标准。当我们需要复制一个实现了该接口的类的实例对象时，我们只要调用其`clone()`函数即可。

`clone()`函数的实现，需要借助一个构造函数，该构造函数接收一个同类型的对象，并将其属性赋值给刚刚创建的新对象（类似于`this.property = prototype.property;`）。比如在C++ 11标准中，这个隐形的构造函数是默认存在的。

**Singleton**：单例模式解决两个问题：1、保证每个类只有一个实例对象，以便控制对共享资源的访问；2、提供一个全局的访问指针，将该实例对象作为全局变量使用。

具体实现步骤为：1、类内部增加一个私有静态属性（`instance`），用来存储单例；2、向外部提供公共静态函数（`getInstance()`）用于获取单例；3、在`getInstance()`内实现类的延迟初始化，第一次调用时创建新的实例并赋值给`instance`并返回，之后的调用直接返回已创建的`instance`；4、将类的构造函数变为私有（private），只有在类内部才能调用。

*注*：Spring框架也使用单例模式，但是Spring Singleton 不同于此处的Singleton。[Spring Singleton vs Singleton Pattern](https://www.javadevjournal.com/spring/spring-singleton-vs-singleton-pattern/)

#### Structural Patterns

**Adapter**：一个常见的适配器是数据转换适配器。比如现有系统可以接收XML格式数据并进行展示，后来新增的第三方数据源只提供JSON格式数据，那么就加一个适配器将JSON格式转换为XML格式。

实现方式：1、适配器为调用方提供一个接口，当调用方通过，适该接口调用适配器时，配器将接收到的请求转换成被调用方能够理解的形式，该方法称为对象适配（Object adapter）；2、另外一种类适配（Class adapter）只在支持多继承的语言中才能实现，比如C++。

**Bridge**：桥接模式比较难理解。这里参考[geeksforgeeks](https://www.geeksforgeeks.org/bridge-design-pattern/)网站的扼要介绍，可以了解到该模式的主要思想。该模式主张将软件分成两层架构，抽象和实现（或者接口和实现、前端和后端等等）。抽象是指类本身，而其能做的事作为实现（所以这里的“实现”和实现接口的“实现”不是同一概念，这里的实现是以接口的形式存在的）。抽象和实现可以单独变化而不影响另外一层结构。桥接模式就是为了应对这种变化而提出的。

本文中的第一个例子（使用形状和颜色）存在不太恰当的地方，它容易让初学者认为形状和颜色是两个并列的属性，但其实作者想表达的，形状是作为形状的子类，而涂色是其能做的事，两者不是并列的，而是存在主次的。geeksforgeeks网站使用Vehicle的例子就不具有这样的迷惑性，因此更易理解。

**Composite**：组合模式适用于树形结构，即包括分支和叶子结点。比如调用树形结构的求和函数，树形结构将遍历其所有分支，每个分支再遍历其所有叶子节点，最终由叶子节点返回结果并向上传递。

具体实现步骤为：1、确保核心模型可以用树形结构表示，即可以分解成简单元素和容器，且容器可以包含简单元素和其他容器；2、为简单元素和容器声明统一的组件接口（component interface），该接口包含所有组件（简单元素和容器）需要实现的函数；3、创建叶子结点类，代表简单的元素，叶子结点类可以有多个；4、创建容器类，该类提供一个数组用来存储子元素，为了使该数组可以同时存放简单元素和容器，数组元素使用组件接口来声明；5、为容器定义添加和删除子元素的函数。

**Decorator**：装饰者，也叫包装器。文章最后的数据源的例子最容易理解，在写入数据之前使用包装器对数据进行压缩和加密，读取数据时使用包装器对数据进行解密和解压缩。其中父类包装器通过实现和被包装对象相同的接口来完成对对象的包装，而子类包装器通过重写这个接口来完成功能的扩展。

具体实现步骤为：1、确认业务域可以表示为有多个可选外层的原始组件；2、提取原始组件和可选层的公共函数，声明为组件接口（component interface）；3、创建组件类（被包装类），定义其基本行为；4、创建基础装饰类（包装器），包含一个属性用来存放被包装对象的引用，该属性使用组件接口，以便既可以指向被包装类，又可以指向其他包装器（这也是为什么要提取包装器和被包装类共同的接口）；5、确保所有类都实现了组件接口；6、创建基础包装器的子类，这些子类在调用父类的行为之前或之后执行自己的行为；7、客户端（调用者）负责创建并组合包装器。

**Facade**：门面模式，关键字是“门”，即入口。有时候我们调用库或者框架的时候，需要使用其非常多的对象和函数，且这些对象或函数要按照一定的规则创建或调用。为了使业务代码和这些复杂的规则相分离，也为了便于库或者代码的替换或升级，应该将框架或库的使用封装到一个类或者方法中，只对外暴露较少的入口。文中使用了视频处理的例子，而我想到的例子是使用POI读写Excel。

**Flyweight**：翻译成“享元模式”虽然直接说明了该模式的内在逻辑，不是flyweight所代表的含义。flyweight（或lightweight）是指拳击运动中的轻量级，在这里则指创建轻量级的对象，以节省内存空间。

粒子系统是一个很好的场景。因为粒子系统会创建非常多的粒子，会占用大量的内存。并且粒子往往具有这样一些属性：1、这些属性是粒子的内在（intrinsic）属性，初始化完成后不再变化；2、这些属性为全部或部分粒子共有，即这些粒子具有相同的属性值。在这种情形下，可以只创建少量的粒子，通过对象的复用模拟大量粒子。内在属性之外的属性称为外在（extrinsic）属性，这些属性会随着程序的运行发生变化，这些属性值转由主程序（context）保存或计算。

因为外在属性的个数未发生变化，单纯的将粒子属性进行内在和外在的拆分不会节省内存，而是由于轻量级对象可以为更多的场景所共享，从而只需创建更少的对象，以达到节省内存的目的。这些少量的对象可以由工厂管理在对象池中。

**Proxy**：代理模式为原始对象提供一个套件，在请求原始对象之前或之后做一些事。这听起来和装饰模式很像，但其实它有更多的权力，完全可以视作原始对象的替代品。比如代理模式可以控制在某些时候不调用原始对象（缓存代理），可以控制原始对象的懒加载和释放（虚拟代理），做一些和业务不相干的事（日志代理），或者将远程调用封装为本地调用（远程代理）。

实现步骤为：1、如果没有预定义的接口，定义一个，使得代理和服务类可以互换（使用接口声明调用）。提取服务接口并非总是可取的，方案B是定义代理类为服务类的子类，以此来继承服务接口。2、创建代理类，该类包含一个属性以存放对服务的引用。通常代理类负责服务对象的创建和管理，有时候，也可能由客户端向代理类构造器中传入一个服务对象。3、根据需求实现代理方法。大多数情况下，在完成代理工作后，依旧将工作移交给服务对象，毕竟自己只是个代理。4、可以考虑引入一个方法，用来确定使用代理还是直接调用服务，这是可选的。5、可以考虑在代理中延迟初始化服务对象。

#### Behavioral Patterns

**Chain of Responsibility**：